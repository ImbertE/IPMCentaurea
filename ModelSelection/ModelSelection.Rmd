---
title: "Model Selection"
author: "Loïc Pages & Eric Imbert"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  word_document: default
---

R codes to find the best models for each vital rate 
Working directory and datafile are defined in the first chunk

First : create set of possibles combinations for fixed/random effects.
Models are fitted using spaMM.

For each vital rate, the best 5 models on AIC/BIC are saved in SelectedModels.RData

Vital rates to model :
Seedling Survival probability (Age=1) 
Plant survival probability (Age>2)
Flowering probability
Growth => Only one model
Fecundity (number of capitula) => Only one model
Seedling size distribution
Establishment rate => Only one model

For each vital rate, details on selected models can be found in dedicated scripts.
e.g. FloweringModelFitted.Rmd...

Otherwise : next step => import the SelectedModels.RData in ModelSelectionReport.Rmd

```{r}
rm(list=ls())
library(knitr)
library(spaMM)
library(tidyverse)
library(splines)
library(foreach)
library(doParallel)
library(rcdd)

cl <- makeCluster(10) #A modifier en fonction du nbr de cores


IPM_data <- read.csv("../data/donneesIPM.csv") #data usual format for IPM
#remove individuals Age and Size unknown
centauree_data <- IPM_data[!is.na(IPM_data$Size0Mars) & !is.na(IPM_data$Age),]
centauree_data$Age[centauree_data$Age > 8] <- 8

spaMM.options(separation_max=70)
```



Integral Projection Model
$$N(y,t+1)=\int (F_a(x,y,t)+P_a(x,y,t))N(x,t)dx$$
$x$ plant size at time $t$, $y$ size at $t+1$, $a$ age at t and $N$ population size

Probability for an individual of age a and size x at time t to become an individual of age a+1 and size y at t+1 :
$$P_a(x,y,t)=s_a(x)(1-f_a(x))g_a(x,y)$$
Density of individuals of size y and age 1 (seedling) at t from reproduction of a plant of size x and age a at t :
$$F_a(x,y,t)=f_a(x)c_a(x)\omega(y)Estb$$


Model selection

Method : 
- Determine the distribution form (gaussian, binomial, etc)
- Create list of fixed effects
- Create list of random effects
- Create all sub-model combinations with these effects
- Test AIC (or BIC) and select the best model

Create list of fixed and random effects
```{r}
# Random effects
r_effects <- c("year", "Pop")

# Fixed effects on which random effects have an effect
f_effects <- c("1 ", "Size0Mars", "Age", "Size0Mars + Age")


# Combinations (fixed effects | random effect) 
ran_combinations <- sapply(f_effects, function(feffect) {
  sapply(r_effects, function(reffect) {
    paste0("(", feffect, "|", reffect, ")")
  })
})

# Add individual effect
random_effects <- c(as.vector(ran_combinations),"1","(1|Individu)")
```


```{r}
# Size fixed effect
size_effects <- c("Size0Mars","poly(Size0Mars,2)","bs(Size0Mars,df=4,degree=2)","bs(Size0Mars,df=3,degree=2)",
                   "poly(Size0Mars,3)","bs(Size0Mars,df=5,degree=3)","poly(Size0Mars,4)")

size_effects2 <- c("offset(Size0Mars)","poly(offset(Size0Mars),2)","bs(offset(Size0Mars),df=4,degree=2)","bs(offset(Size0Mars),df=3,degree=2)",
                   "poly(offset(Size0Mars),3)","bs(offset(Size0Mars),df=5,degree=3)","poly(offset(Size0Mars),4)")

# Age fixed effect
age_effects <- c("Age", "poly(Age,2)", "bs(Age,degree=2,knots=6.5)", "poly(Age,3)", "bs(Age,degree=3,knots=6.5)", "bs(Age,degree=3,knots=c(1.5,6.5))", "poly(Age,4)")

age_effects2 <- c("Age", "poly(Age,2)", "bs(Age,degree=2,knots=6.5)", "poly(Age,3)", "bs(Age,degree=3,knots=6.5)", "poly(Age,4)") #splines with only one knot

age_effects3 <- c("Age", "poly(Age,2)", "poly(Age,3)", "poly(Age,4)") #no splines
```


```{r}
#Functions that remove unnecessary repetitions 
# Example: if there is 2 random effects (x|year) we remove the combination from the list.
is_valid_combination <- function(comb) {
  comb <- sort(comb)  # Trier pour vérifier l'ordre
  if (sum(grepl("\\|year", comb)) >= 2) return(FALSE)
  if (sum(grepl("\\|Pop", comb)) >= 2) return(FALSE)
  if (sum(grepl("\\|Individu", comb)) >= 2) return(FALSE)
  
  if (!"1" %in% comb) return(FALSE) # 1 for intercept is needed for all combinations
  return(TRUE)
}

# Remove individual effect
individual_combination <- function(comb){
    if ("(1|Individu)" %in% comb) return(FALSE)
  return(TRUE)
}

# Function that removes non-performing combinations where there is a random individual effect (for survival age>1).
is_valid_Individu <- function(comb){
  if ("(1|Individu)" %in% comb && any(grepl("^bs", comb))) return(FALSE)
  if ("(1|Individu)" %in% comb && "(Size0Mars + Age|year)" %in% comb) return(FALSE)
  if ("(1|Individu)" %in% comb && "(Age|year)" %in% comb) return(FALSE)
  if ("(1|Individu)" %in% comb && "(Size0Mars|year)" %in% comb) return(FALSE) 
  if ("(1|Individu)" %in% comb && "(Size0Mars + Age|Pop)" %in% comb) return(FALSE)
  if ("(1|Individu)" %in% comb && "(Age|Pop)" %in% comb) return(FALSE)
  if ("(1|Individu)" %in% comb && "(Size0Mars|Pop)" %in% comb) return(FALSE)
  return(TRUE)
}

# Function that removes combinations where there is a spline function and the random effect individual
is_valid_Individu2 <- function(comb){
  if ("(1|Individu)" %in% comb && any(grepl("^bs", comb))) return(FALSE)
  return(TRUE)
}

# Remove combination where there is age in random effect (for seedling survival)
rage_combination <- function(comb){
  if ("(Age|Pop)" %in% comb) return(FALSE)
  if ("(Size0Mars + Age|Pop)" %in% comb) return(FALSE)
  if ("(Age|year)" %in% comb) return(FALSE)
  if ("(Size0Mars + Age|year)" %in% comb) return(FALSE)
  return(TRUE)
}
```


Generate combinations list
```{r} 
combinations <- list()

# Combinations of all random effects
for (n in 1:length(random_effects)) {
  combinations <- c(combinations, combn(random_effects, n, simplify = FALSE))
}
combinations <- Filter(is_valid_combination, combinations) 


combi <- combinations
# Add size combinations
for (s in size_effects) {
  for (combo in combi) {
    combinations <- c(combinations, list(c(s, combo)))
  }
}

combi_0 <- Filter(is_valid_Individu,combinations)

# Add all possible age combinations
combi <- combinations
for (a in age_effects) {
    for (combo in combinations) {
        combi <- c(combi, list(c(a, combo)))
      }
  }

# Add spline simplified age combinations
combi2 <- combinations
for (a in age_effects2) {
    for (combo in combinations) {
        combi2 <- c(combi2, list(c(a, combo)))
      }
}

# Add age combinations without spline
combi3 <- combinations
for (a in age_effects3) {
    for (combo in combinations) {
        combi3 <- c(combi3, list(c(a, combo)))
      }
}


validIndividu2 <- Filter(is_valid_Individu,combi2) # Combinaisons simplifiée de l'effet individus

combi_flow <- Filter(individual_combination,combi3) # Flowering combinations, absence de splines pour l effet age

combi_notInd <- Filter(individual_combination,combi) # Combinations without individual effect 

combi_surv1 <- Filter(individual_combination,combi_0)  #combi for seedling survival no age effect
combi_surv1 <- Filter(rage_combination,combi_surv1) # Seedling survival combinations

combi_surv2 <- Filter(is_valid_Individu,combi) # Rosette survival combinations
```



Other combinations
```{r}
combi_plantule <- c("1","1 + (1|year) + (1|Pop) + (1|Pop:year)","1 + (1|year) + (1|Pop)","1 + (1|year) + (1|Pop:year)","1 + (1|Pop) + (1|Pop:year)","1 + (1|year)","1 + (1|Pop)","1 + (1|Pop:year)")

# Remplace size par log(size)
combi_growth_log <- lapply(combi_notInd, function(x) gsub("Size0Mars", "log(Size0Mars)", x))
combi_growthIndividu_log <- lapply(validIndividu2, function(x) gsub("Size0Mars", "log(Size0Mars)", x))

#variance résiduelle pour la croissance - see below for growth
combi_resvar <- c("1","log(Age)","log(Size0Mars)","log(Size0Mars) + log(Age)", "log(Size0Mars) + log(Age) + (1|year) + (1|Pop)")

combi_estb <- list()
for (combo in combi_plantule) {
        combi_estb <- c(combi_estb, list(c("offset(log(Capitule))", combo)))
}

```

Combinations for fecundity : intercept=0 (size=0, fecundity=0) -not used
```{r}
#Fonction qui transforme les 1 en 0 : fixe l'intercept à 0 (même dans les effets aléatoires)
modify_effects_to0 <- function(effect_list) {
  lapply(effect_list, function(combination) {
    sapply(combination, function(term) {
      if (term == "1") {
        return("0")
      } else if (grepl("^\\(", term) && !grepl("0 \\+ ", term) && !grepl("1 \\|", term)) {
        return(sub("^\\(", "(0 + ", term))
      } else {
        return(term)
      }
    }, USE.NAMES = FALSE)
  })
}

valid0 <- function(comb) {
    # Must contain "(1|Pop)" and "(1|year)"
    if ("(1 |Pop)" %in% comb) return(FALSE)
    if ("(1 |year)" %in% comb) return(FALSE)
    return(TRUE)
}

combi_int0 <- combi_0
combi_int0 <- modify_effects_to0(combi_int0)
combi_int0 <- Filter(valid0,combi_int0[-1])
```


Extract BIC
```{r}
# N the number of subjects
# ntot the total number of observations
#DoF => spaMM
extractBIC <- function(fit, ntot, N=1){
  extractAIC(fit)[[2]] +(log(ntot)-2)*DoF(fit)[[3]] + log(N)*DoF(fit)[[1]]
}
```


Survival probability
As the species is monocarpic, only non flowering plants are considered
```{r}
survdata <- centauree_data[centauree_data$Flowering!=1 & !is.na(centauree_data$Survie),]
survdata1 <- survdata[survdata$Age==1,] #Seedlings
survdata2 <- survdata[survdata$Age>1,]
```

It is recommended to test the more complex model first to see if it is working well
```{r}
survfit <- fitme(Survie ~ 1 + bs(Size0Mars,df=5,degree=3) + bs(Age,degree=3,knots=6.5)+ (Age+Size0Mars|year) + (Age+Size0Mars|Pop) + (1|Individu), data=survdata2)
summary(survfit)
```

Seedling survival

Fixed effect : size (polynomes and splines)
random effects : population, year (effect on intercept and size) 
```{r}
ntot <- length(survdata1$Individu)
resp <- "Survie"
combi <- combi_surv1
length_combi = length(combi)

cl <- makeCluster(10)
registerDoParallel(cl)

result <- foreach(i=1:length_combi, .packages=c("splines","spaMM")) %dopar% {
  set_effects <- combi[i]
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste(resp, "~", effect_formula))
  fit <- fitme(formula, data = survdata1, family=binomial, method = "PQL/L")
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}

stopCluster(cl)

combiresult <- list()
AICresult <- list()
BICresult <- list()
for(i in 1:length(result)){ 
  AICresult[i] <- result[[i]][1]
  BICresult[i] <- result[[i]][2]
  combiresult[i] <- result[[i]][3]
}

posAIC <- order(unlist(AICresult))[1:5]
posBIC <- order(unlist(BICresult))[1:5]

survAIC <- AICresult[posAIC]
survBIC <- BICresult[posBIC]
survmodAIC <- combiresult[posAIC]
survmodBIC <- combiresult[posBIC]

Seedling_survAIC <- AICresult[posAIC]
Seedling_survBIC <- BICresult[posBIC]
Seedling_survmodAIC <- combiresult[posAIC]
Seedling_survmodBIC <- combiresult[posBIC]
```


Plant survival Age>1

fixed effects : size (polynomes and splines) 
                age (polynome and splines)

random effects : population, year (effect on intercept and size 
                individual (intercept)
                
```{r}
ntot <- length(survdata2$Individu)
resp <- "Survie"
combi <- combi_surv2
length_combi = length(combi)
cl <- makeCluster(10)
registerDoParallel(cl)

result <- foreach(i=1:length_combi, .packages=c("splines","spaMM")) %dopar% {
  set_effects <- combi[i]
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste(resp, "~", effect_formula))
  fit <- fitme(formula, data = survdata2, family=binomial, method = "PQL/L")
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}

stopCluster(cl)

combiresult <- list()
AICresult <- list()
BICresult <- list()
for(i in 1:length(result)){ 
  AICresult[i] <- result[[i]][1]
  BICresult[i] <- result[[i]][2]
  combiresult[i] <- result[[i]][3]
}

posAIC <- order(unlist(AICresult))[1:5]
posBIC <- order(unlist(BICresult))[1:5]

Plant_survAIC <- AICresult[posAIC]
Plant_survBIC <- BICresult[posBIC]
Plant_survmodAIC <- combiresult[posAIC]
Plant_survmodBIC <- combiresult[posBIC]
```


Reproduction

Flowering : binomial variable (0/1).

Combinations of fixed and random effects have been reduced

The Individual effect is  not considered because models do not convergence when this effect is included

For age, no spline has been implemented

Other combinations -for instance splines on the size- have not been considered  when separation lead to a no convergent situation 
```{r}
#Verification de la séparation

i <- 1L
combi_fleur <- list()

for (set_effects in combi_flow) {
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste("Flowering", "~", effect_formula))
  if (is_separated.formula(formula, data = centauree_data, method = "PQL/L") == FALSE){
    combi_fleur[[i]] <- set_effects
    i <- i + 1L
  }
}
```

Test a complex model
```{r}
fitme(Flowering ~ 1+ poly(Size0Mars,4) + (Size0Mars+Age|year)+poly(Age,3)+(Size0Mars+Age|Pop),
                    family=binomial,
                    data=centauree_data,
                    method="PQL/L")
```


```{r}
resp <- "Flowering"
ntot <- length(centauree_data$Individu)

combi <- combi_fleur
length_combi <- length(combi)

cl <- makeCluster(10)
registerDoParallel(cl)

result <- foreach(i=1:length_combi, .packages=c("splines","spaMM")) %dopar% {
  set_effects <- combi[i]
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste(resp, "~", effect_formula))
  fit <- fitme(formula, data = centauree_data, family=binomial, method = "PQL/L")
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}

stopCluster(cl)

combiresult <- list()
AICresult <- list() #liste complete
BICresult <- list() #liste complete
for(i in 1:length(result)){ 
  AICresult[i] <- result[[i]][1]
  BICresult[i] <- result[[i]][2]
  combiresult[i] <- result[[i]][3]
}


posAIC <- order(unlist(AICresult))[1:5] #5 meilleurs modeles
posBIC <- order(unlist(BICresult))[1:5] #5 meilleurs modeles

flowAIC <- AICresult[posAIC]
flowBIC <- BICresult[posBIC]
flowmodAIC <- combiresult[posAIC]
flowmodBIC <- combiresult[posBIC]
```

## Croissance
```{r}
growthdata <- centauree_data[!is.na(centauree_data$Size1Mars), ]
growthdata <- growthdata[growthdata$Size1Mars != 0, ]
```


```{r}
# Growthglm1 <- fitme(Size1Mars ~ 1 + bs(Size0Mars,df=5,degree=3) + bs(Age,degree=3,knots=6.5)+(Age+Size0Mars|year)+(Age+Size0Mars|Pop),
#                     resid.model =~log(Size0Mars)+log(Age),
#                     data=growthdata)
# summary(Growthglm1)
```

For Growth, the process is time consuming and not as simple as the other vital rates


Step 1 :
Test linear models using the generic script as describe above

```{r, eval=FALSE}
resp <- "Size1Mars"
combi <- combi_notInd
n <- length(growthdata$Individu)
length_combi <- length(combi)
lv <- length(combi_resvar)
cl <- makeCluster(10)

registerDoParallel(cl)
result <- foreach(i = 1:length_combi, .packages=c("splines","spaMM")) %dopar% {
    set_effects <- combi[i]
    effect_formula <- paste(unlist(set_effects), collapse = "+")
    formula <- as.formula(paste(resp, "~", effect_formula))
    fit <- fitme(formula, data = growthdata, method = "PQL/L")
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}
stopCluster(cl)
```

As the models selected with the AIC/BIC have a low good goodness-of-fit, we tested models with parameters for residuals

fitme(formula, data = growthdata, resid.model = ~ XXXXX)

```{r, eval=FALSE}
resp <- "Size1Mars"

combi <- combi_notInd

n <- length(growthdata$Individu)

length_combi <- length(combi)
lv <- length(combi_resvar)
cl <- makeCluster(10)
registerDoParallel(cl)

result <- foreach(i = 1:length_combi, .packages=c("splines","spaMM")) %dopar% {
    set_effects <- combi[i]

    effect_formula <- paste(unlist(set_effects), collapse = "+")
    formula <- as.formula(paste(resp, "~", effect_formula))
    formula_resvar1 <- as.formula(paste("~", combi_resvar[1]))
    formula_resvar2 <- as.formula(paste("~", combi_resvar[2]))
    formula_resvar3 <- as.formula(paste("~", combi_resvar[3]))
    formula_resvar4 <- as.formula(paste("~", combi_resvar[4]))
    formula_resvar5 <- as.formula(paste("~", combi_resvar[5]))
    
    
    fit1 <- fitme(formula, data = growthdata, resid.model = formula_resvar1)
    fit2 <- fitme(formula, data = growthdata, resid.model = formula_resvar2)
    fit3 <- fitme(formula, data = growthdata, resid.model = formula_resvar3)
    fit4 <- fitme(formula, data = growthdata, resid.model = formula_resvar4)
    fit5 <- fitme(formula, data = growthdata, resid.model = formula_resvar5)

  c(extractAIC(fit1)[[2]],extractAIC(fit2)[[2]],extractAIC(fit3)[[2]],extractAIC(fit4)[[2]],extractAIC(fit5)[[2]],effect_formula)
  }


stopCluster(cl)

result2 <- data.frame()
AICresult <- list()
combiresult <- list()

for(i in 1:length(result)){
  for(j in 1:length(combi_resvar)){
    AICresult[j] <- result[[i]][j]
  }
  posAIC <- order(unlist(AICresult))[1]
  combiresult <- result[[i]][length(combi_resvar)+1]
  result2[i,1] <- round(as.numeric(AICresult[posAIC]))
  result2[i,2] <- combiresult
  result2[i,3] <- combi_resvar[posAIC]
}
names(result2)<-c("AIC","Model","ResidVar")

combiresult <- list()
varresult <- list()
AICresult <- list()
for(i in 1:length(result)){
  AICresult[i] <- result2$AIC[i]
  combiresult[i] <- result2$Model[i]
  varresult[i] <- result2$ResidVar[i]
}

posAIC <- order(unlist(AICresult))[1:5]

growthAIC2 <- AICresult[posAIC]
growthmodAIC2 <- combiresult[posAIC]
growthvarAIC2 <- varresult[posAIC]
growthAIC2
growthmodAIC2
growthvarAIC2
```


=> 5 models can be selected 
Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Age|year) + (1|Pop),
                   resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop)

Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop),
resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop)

Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars|Pop),
resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop)
Size1Mars ~ 1 + bs(Size0Mars,df=5,degree=3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop)
resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop)
Size1Mars ~ 1 + bs(Size0Mars,df=5,degree=3)+ bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars|Pop)
resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop)

```{r}
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Age|year) + (1|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm2 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop),
                     resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm3 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm4 <- fitme(Size1Mars ~ 1 + bs(Size0Mars,df=5,degree=3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop), data=growthdata)

Growthglm5 <- fitme(Size1Mars ~ 1 + bs(Size0Mars,df=5,degree=3)+ bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop), data=growthdata)

extractAIC(Growthglm1)[[2]]
extractAIC(Growthglm2)[[2]]
extractAIC(Growthglm3)[[2]]
extractAIC(Growthglm4)[[2]]
extractAIC(Growthglm5)[[2]]
```

Better after a Boxcox transformation for SIZE
Size1Mars^*0.4343354
Size0Mars^*0.4343354

```{r}
Growthglm1 <- fitme(Size1Mars^0.4343354 ~ 1 + poly(Size0Mars^0.4343354,3) + bs(Age,degree=2,knots=6.5) + (Age|year) + (1|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm2 <- fitme(Size1Mars^0.4343354 ~ 1 + poly(Size0Mars^0.4343354,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop),
                     resid.model= ~ log(Size0Mars) + log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm3 <- fitme(Size1Mars^0.4343354 ~ 1 + poly(Size0Mars^0.4343354,3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars+Age|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop),data=growthdata)

Growthglm4 <- fitme(Size1Mars^0.4343354 ~ 1 + bs(Size0Mars^0.4343354,df=5,degree=3) + bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (1|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop), data=growthdata)

Growthglm5 <- fitme(Size1Mars^0.4343354 ~ 1 + bs(Size0Mars^0.4343354,df=5,degree=3)+ bs(Age,degree=2,knots=6.5) + (Size0Mars+Age|year) + (Size0Mars|Pop),
                     resid.model = ~ log(Size0Mars)+log(Age) + (1|year) + (1|Pop), data=growthdata)

extractAIC(Growthglm1)[[2]]
extractAIC(Growthglm2)[[2]]
extractAIC(Growthglm3)[[2]]
extractAIC(Growthglm4)[[2]]
extractAIC(Growthglm5)[[2]]

gof(Growthglm1)
gof(Growthglm2)
gof(Growthglm3)
gof(Growthglm4)
gof(Growthglm5)
```

Considering AIC and gof => Growthglm1


Fecundity (nb of seed heads)

First test with the generic script :
```{r,eval=FALSE}
cptldata <- centauree_data[centauree_data$Flowering!=0,]
ntot <- length(cptldata$Individu)
resp <- "Capitule"
combi <- combi_notInd
#combi <- combi_int0
length_combi <- length(combi)
cl <- makeCluster(10)
registerDoParallel(cl)

result <- foreach(i = 1:length_combi,.packages=c("splines","spaMM")) %dopar% {
  set_effects <- combi[i]
  
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste(resp, "~", effect_formula))
  fit <- fitme(formula,data = cptldata,family=Poisson(trunc = 0L))
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}

stopCluster(cl)

combiresult <- list()
AICresult <- list()
BICresult <- list()
for(i in 1:length(result)){ 
  AICresult[i] <- result[[i]][1]
  BICresult[i] <- result[[i]][2]
  combiresult[i] <- result[[i]][3]
}

posAIC <- order(unlist(AICresult))[1:5]
posBIC <- order(unlist(BICresult))[1:5]
cptlAIC <- AICresult[posAIC]
cptlBIC <- BICresult[posBIC]
cptlmodAIC <- combiresult[posAIC]
cptlmodBIC <- combiresult[posBIC]
```


Results are not good
So specific models are tested
```{r}

cptldata <- centauree_data[centauree_data$Flowering!=0,]
Cptlglm1 <- fitme(log(Capitule) ~ 1  + Size0Mars + (Age|year), 
                  data=cptldata)

#Best Model according to the previous script
Cptlglm2 <- fitme(Capitule ~ 1 + bs(Size0Mars,df=4,degree=2) + bs(Age,degree=3,knots=c(1.5,6.5)) + (Size0Mars|Pop) + (Size0Mars + Age|year), data=cptldata, family= Poisson(trunc=0L))

Cptlglm3 <- fitme(Capitule ~ 1 + poly(Size0Mars,2) + (Size0Mars|Pop) + (Size0Mars|year), 
                   data=cptldata, family= Poisson(trunc=0L))

```

Best model Cptlglm1


Seedling size (age=1)

Model with a log-Gamma distribution 

Random effects are year, population and interaction year:population.


```{r}
resp <- "Size0Mars"
plantule_data <- centauree_data[centauree_data$Age==1,]
ntot <- length(plantule_data$Individu)
length_combi <- length(combi_plantule)
result <- foreach(i = 1:length_combi) %do% {
  set_effects <- combi_plantule[i]
  effect_formula <- paste(unlist(set_effects), collapse = "+")
  formula <- as.formula(paste(resp, "~", effect_formula))
  fit <- fitme(formula,data = plantule_data,family = Gamma(log))
  c(extractAIC(fit)[[2]],extractBIC(fit,ntot),set_effects)
}

combiresult <- list()
AICresult <- list()
BICresult <- list()
for(i in 1:length(result)){ 
  AICresult[i] <- result[[i]][1]
  BICresult[i] <- result[[i]][2]
  combiresult[i] <- result[[i]][3]
}


posAIC <- order(unlist(AICresult))[1:5]
posBIC <- order(unlist(BICresult))[1:5]

pltAIC <- AICresult[posAIC]
pltBIC <- BICresult[posBIC]
pltmodAIC <- combiresult[posAIC]
pltmodBIC <- combiresult[posBIC]
```



Establishment rate 
Relationship between number of seedlings observed per quadrat on year t+1 depending on the number of capitula observed on the same quadrat on year t

First use the predicted values to replace missing data using model Cptlglm1
```{r}
cptldata_predi <- IPM_data[IPM_data$Flowering==1,] %>%
  mutate(Capitule = ifelse(is.na(Capitule),exp(predict(Cptlglm1)),Capitule))

#Number of seedlings
plt <- IPM_data %>% 
  filter(Age==1) %>% 
  group_by(Quadrat,year,Pop) %>% 
  summarize(NombrePlantules = sum(Age))

cptl <- cptldata_predi %>% 
  group_by(Quadrat,year,Pop) %>% 
  summarize(Capitule = sum(Capitule))
cptl$year <- cptl$year+1

Estb <- inner_join(plt,cptl, by=join_by(Quadrat,year,Pop))
```

Number of seedlings observed is dependent on the number of seed heads :
```{r}
Estbglm <- fitme(NombrePlantules ~ 1 + offset(log(Capitule)) + (1|Pop:year),data = Estb,
                  family = Poisson(log))

```

On enregistre les modeles retenus

```{r}

save(Seedling_survAIC,Seedling_survBIC,Seedling_survmodAIC,Seedling_survmodBIC,
  Plant_survAIC,Plant_survBIC,Plant_survmodAIC,Plant_survmodBIC,
  flowAIC,flowBIC,flowmodAIC,flowmodBIC,
  Growthglm1,Cptlglm1,pltAIC,pltmodAIC,Estbglm,
  file="SelectedModels.RData"
)
```

